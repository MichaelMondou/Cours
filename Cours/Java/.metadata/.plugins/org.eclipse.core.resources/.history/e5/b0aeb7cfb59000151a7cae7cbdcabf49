package hex;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

public class Grille {

	static final int longueur = 7;
	static final int hauteur = 7;

	private ArrayList<ArrayList<Cellule>> cellules = new ArrayList<ArrayList<Cellule>>();

	public Grille() {
		int abscisse = 0;
		int ordonée = 0;

		for (int i = 0; i < longueur; i++) {
			ArrayList<Cellule> cellules_temp = new ArrayList<Cellule>();
			for (int j = 0; j < hauteur; j++) {
				abscisse = 170 + i * 49;
				ordonée = 250 + j * 55;
				cellules_temp.add(new Cellule(abscisse, ordonée, j, i, Color.GRAY));
			}
			getCellules().add(cellules_temp);
		}
		miseEnPlace();
	}

	/**
	 * Permet de mettre le plateau en décalé
	 */
	public void miseEnPlace() {
		for (int i = 0; i < Grille.longueur; i++) {
			for (int j = 0; j < Grille.hauteur; j++) {
				int ordonée = this.getCellules().get(i).get(j).getY();
				ordonée -= 27 * i;
				this.getCellules().get(i).get(j).setY(ordonée);
				this.getCellules().get(i).get(j).creerPolygone();
			}
		}
	}

	public void affecterZone(Cellule cellule, Joueur joueur) {

		if (this.around(cellule, joueur).size() > 0) {
			this.updateGrid(cellule, joueur);
			joueur.updateZone();
		} else {
			cellule.setZone(joueur.getZone());
			joueur.upZone();
		}
		if (this.fin(joueur)) {
			if(joueur.getCouleur() == Color.WHITE)
				System.out.println("blanc gagné");
			else
				System.out.println("noir gagné");
		}

	}

	private boolean fin(Joueur joueur) {
		boolean zone1_player1 = false;
		boolean zon2_player1 = false;
		boolean fin = false;
		
		boolean fin3 = false;
		boolean fin4 = false;
		
		if(joueur.getCouleur() == Color.BLACK){
			for (int i = 0; i < joueur.getCellules_joueur().size(); i++) {
				if (joueur.getCellules_joueur().get(i).getC() == 6 && joueur.getCellules_joueur().get(i).getZone() == 1) {
					zone1_player1 = true;
				}
			}
			for (int i = 0; i < joueur.getCellules_joueur().size(); i++) {
				if (joueur.getCellules_joueur().get(i).getC() == 0 && joueur.getCellules_joueur().get(i).getZone() == 1) {
					zon2_player1 = true;
				}
			}
			if (zone1_player1 && zon2_player1) {
				fin = true;
			}
		}
		else{
			for (int i = 0; i < joueur.getCellules_joueur().size(); i++) {
				if (joueur.getCellules_joueur().get(i).getL() == 6 && joueur.getCellules_joueur().get(i).getZone() == 1) {
					fin3 = true;
				}
			}
			for (int i = 0; i < joueur.getCellules_joueur().size(); i++) {
				if (joueur.getCellules_joueur().get(i).getL() == 0 && joueur.getCellules_joueur().get(i).getZone() == 1) {
					fin4 = true;
				}
			}
			if (fin3 && fin4) {
				fin = true;
			}
		}
		return fin;
	}

	private void updateGrid(Cellule cellule, Joueur joueur) {
		ArrayList<Cellule> neighbors = new ArrayList<Cellule>();
		neighbors = this.around(cellule, joueur);
		cellule.setZone(neighbors.get(0).getZone());
		if (neighbors.size() > 1) {
			for (int i = 1; i < neighbors.size() - 1; i++)
				updateGrid(neighbors.get(i), joueur);
		}
	}

	private ArrayList<Cellule> around(Cellule cellule, Joueur joueur) {

		int left = cellule.getC() - 1;
		int right = cellule.getC() + 1;
		int top = cellule.getL() - 1;
		int bottom = cellule.getL() + 1;

		ArrayList<Cellule> neighbors = new ArrayList<Cellule>();

		for (int i = 0; i < joueur.getCellules_joueur().size(); i++) {

			int ligne = joueur.getCellules_joueur().get(i).getL();
			int colonne = joueur.getCellules_joueur().get(i).getC();

			if (colonne == left && ligne == cellule.getL()) {
				// regarder gauche
				neighbors.add(joueur.getCellules_joueur().get(i));
			} else if (colonne == right && ligne == cellule.getL()) {
				// regarder droite
				neighbors.add(joueur.getCellules_joueur().get(i));
			} else if (ligne == top && colonne == cellule.getC()) {
				// regarder haut
				neighbors.add(joueur.getCellules_joueur().get(i));
			} else if (ligne == bottom && colonne == cellule.getC()) {
				// regarder bas
				neighbors.add(joueur.getCellules_joueur().get(i));
			} else if (colonne == left && ligne == top) {
				// gerer diag gauche
				neighbors.add(joueur.getCellules_joueur().get(i));
			} else if (colonne == right && ligne == bottom) {
				// gerer diag droite
				neighbors.add(joueur.getCellules_joueur().get(i));
			}
		}
		Collections.sort(neighbors);
		return neighbors;

	}

	public ArrayList<ArrayList<Cellule>> getCellules() {
		return cellules;
	}

	public void setCellules(ArrayList<ArrayList<Cellule>> cellules) {
		this.cellules = cellules;
	}
}
